#!/bin/bash
##################################################
#
# vim: ai:ts=4:sw=4:noet:sts=4:ft=sh
#


##
# _exec_command
#
# param1 = command
# param2 = Fail command
# param3 = Success command
#
function _exec_command () {
	local COMMAND=${1}
	[[ ${2} ]] && local FAIL=${2} || local FAIL="NOTSET"
	[[ ${3} ]] && local SUCCESS=${3} || local SUCCESS="NOTSET"
	if ${SHOW_VERBOSE}; then
		# log STDOUT and STDERR, send both to STDOUT
		_e "\n${bldylw}" "COMMAND" "${COMMAND}"
		eval "${COMMAND} &> >(tee -a ${CURRENT_LOG:-${DINNER_LOG_DIR}/dinner_general.log}) 2> >(tee -a ${CURRENT_ERRLOG:-${DINNER_LOG_DIR}/dinner_general_error.log})"
	else
		# log STDOUT and STDERR but send only STDERR to STDOUT
		printf "%13b:\t%b\n" "COMMAND" "${COMMAND}" &> /dev/null > >( tee -a ${CURRENT_LOG:-${DINNER_LOG_DIR}/dinner_general.log} ${CURRENT_ERRLOG:-${DINNER_LOG_DIR}/dinner_general_error.log} )
		eval "${COMMAND} &>>${CURRENT_LOG:-${DINNER_LOG_DIR}/dinner_general.log} 2>>${CURRENT_ERRLOG:-${DINNER_LOG_DIR}/dinner_general_error.log}"
	fi
	local EXIT_CODE=${?}
	printf "%13b:\t%b\n" "EXIT CODE" "${EXIT_CODE}" &> /dev/null > >( tee -a ${CURRENT_LOG:-${DINNER_LOG_DIR}/dinner_general.log} ${CURRENT_ERRLOG:-${DINNER_LOG_DIR}/dinner_general_error.log} )
	if [ "${EXIT_CODE}" != 0 ] && [ "${FAIL}" != "NOTSET" ]; then
		eval ${FAIL} ${EXIT_CODE}
	elif [ "${SUCCESS}" != "NOTSET" ]; then
		eval ${SUCCESS}
	fi
	return ${EXIT_CODE}
}

function _dinner_update () {
	_e_pending "Checking for updates"
	eval "cd ${DINNER_DIR}"
	eval "$(which git) pull --no-stat --no-progress 2>${DINNER_TEMP_DIR}/dinner_update.err >${DINNER_TEMP_DIR}/dinner_update.log"
	if [ "${?}" == "0" ]; then
		if [ "$(cat ${DINNER_TEMP_DIR}/dinner_update.log)" != "Already up-to-date." ]; then
			_e_pending_success "Successfully updated"
			_e_notice "Restart your Shell or run: \"source ${DINNER_DIR}/dinner.sh\""
		else
			_e_pending_success "Already up-to-date."
		fi
	else
		_e_pending_error "while Dinner update, see details below:\n"
		while read -r LINE; do
			printf "${bldred}%11b\t%b${txtdef}" " " "${LINE}\n"
		done < ${DINNER_TEMP_DIR}/dinner_update.err
	fi
}


function _generate_user_message () {
	echo -e "${1}" >> "${DINNER_TEMP_DIR}/mail_user_message.txt"
}

function _generate_admin_message () {
	echo -e "${1}" >> "${DINNER_TEMP_DIR}/mail_admin_message.txt"
}

function _generate_local_manifest () {
	if [ "${#LOCAL_MANIFEST[@]}" != 0 ]; then
		local CURRENT_LOCAL_MANIFEST=${REPO_DIR}/.repo/local_manifests/dinner_${CURRENT_CONFIG}.xml
		_e_pending "Generating Local Manifest..."
		printf "%s\n" '<?xml version="1.0" encoding="UTF-8"?>' > ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml
		printf "%s\n" '<manifest>' >> ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml
		for LINE in "${LOCAL_MANIFEST[@]}"; do
			printf "\t%s\n" "${LINE}" >> ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml
		done
		printf "%s\n" '</manifest>' >> ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml
		if [ ! -e ${CURRENT_LOCAL_MANIFEST} ] || [ "$(${MD5_BIN} ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml | awk '{ print $1 }')" != "$($MD5_BIN ${CURRENT_LOCAL_MANIFEST} | awk '{ print $1 }')" ]; then
			mv ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.xml ${CURRENT_LOCAL_MANIFEST}
			FORCE_SYNC=true
			_e_pending_success "Successfully generated Local Manifest."
		else
			_e_pending_success "Already newest, no changes needed."
		fi
	fi
}

function _check_prerequisites () {
	eval CURRENT_LOG="${DINNER_LOG_DIR}/dinner_${CURRENT_CONFIG}_${CURRENT_LOG_TIME}.log"
	eval CURRENT_ERRLOG="${DINNER_LOG_DIR}/dinner_${CURRENT_CONFIG}_${CURRENT_LOG_TIME}_error.log"
	printf "LOGFILE GENERATED BY DINNER ${DINNER_VERSION} \(https://github.com/NemesisRE/dinner)\nThis Combined Log contains messages from STDOUT and STDERR\n\n" &> ${CURRENT_LOG:-${DINNER_LOG_DIR}/dinner_general.log}
	printf "LOGFILE GENERATED BY DINNER ${DINNER_VERSION} (https://github.com/NemesisRE/dinner)\nThis Error Log contains only messages from STDERR\n\n" &> ${CURRENT_ERRLOG:-${DINNER_LOG_DIR}/dinner_general_error.log}

	if [ -f "${DINNER_DIR}/config.d/${CURRENT_CONFIG}" ]; then
		_exec_command "source ${DINNER_DIR}/config.d/${CURRENT_CONFIG}"
	else
		_e_fatal "Config \"${CURRENT_CONFIG}\" not found!"
	fi

	_check_variables

	_source_envsetup

	if [ -x ${REPO_DIR}/vendor/cm/get-prebuilts ]; then
		_exec_command "${REPO_DIR}/vendor/cm/get-prebuilts"
	fi

	_set_current_variables

	_exec_command "cd \"${REPO_DIR}\""

	_e_notice "Starting work on config \"${CURRENT_CONFIG}\"..."
}

function _source_envsetup () {
	if [ ! -d "${REPO_DIR}/.repo" ]; then
		_e_fatal "${REPO_DIR} is not a Repo!"
	elif [ -f "${REPO_DIR}/build/envsetup.sh" ]; then
		_exec_command "source ${REPO_DIR}/build/envsetup.sh"
	else
		_e_fatal "${REPO_DIR}/build/envsetup.sh could not be found."
	fi
}

function _set_current_variables () {
	#Set initial exitcodes
	OVERALL_EXIT_CODE=0
	CURRENT_BUILD_SKIPPED=false
	CURRENT_SYNC_REPO_EXIT_CODE=0
	CURRENT_BUILD_STATUS=false
	CURRENT_CONFIG_EXIT_CODE=0
	CURRENT_BRUNCH_DEVICE_EXIT_CODE=0
	CURRENT_MOVE_BUILD_EXIT_CODE=0
	CURRENT_PRE_BUILD_COMMAND_EXIT_CODE=0
	CURRENT_POST_BUILD_COMMAND_EXIT_CODE=0
	CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE=0
	CURRENT_SEND_MAIL_EXIT_CODE=0

	#Set current config Variables
	eval CURRENT_REPO_NAME=$(echo ${REPO_DIR} | sed 's/\//_/g')
	eval CURRENT_LASTSYNC_MEM="${DINNER_MEM_DIR}/${CURRENT_REPO_NAME}.mem"
	eval CURRENT_REPOPICK="\"${REPOPICK}\""
	eval CURRENT_DEVICE="${BUILD_FOR_DEVICE}"
	eval CURRENT_PRE_BUILD_COMMAND="${PRE_BUILD_COMMAND}"
	eval CURRENT_POST_BUILD_COMMAND="${POST_BUILD_COMMAND}"
	eval CURRENT_TARGET_DIR="${TARGET_DIR}"
	eval CURRENT_CLEANUP_OLDER_THAN="${CLEANUP_OLDER_THAN}"
	eval CURRENT_MAIL="${MAIL}"
	eval CURRENT_ADMIN_MAIL="${ADMIN_MAIL}"
	eval CURRENT_DOWNLOAD_LINK="${DOWNLOAD_LINK}"
	eval CURRENT_STATUS="failed"
	[[ $CURRENT_CHANGELOG_ONLY ]] && CURRENT_CHANGELOG_ONLY="true" || CURRENT_CHANGELOG_ONLY="false"
	[[ $CURRENT_CLEAN_ONLY ]] && CURRENT_CLEAN_ONLY="true" || CURRENT_CLEAN_ONLY="false"
}

function _check_variables () {
	# Check essentials
	if [ ! ${REPO_BIN} ] || [ ! -x ${REPO_BIN} ]; then
		_e_fatal "Repo binary (${REPO_BIN}) is not found or not executable!"
	fi

	if [ ! "${REPO_DIR}" ]; then
		_e_fatal "REPO_DIR is not set!"
	elif [ ! ${BUILD_FOR_DEVICE} ]; then
		_e_fatal "No Device given! Stopping..."
	fi

	if [ ! ${SKIP_SYNC_TIME} ] || [ -z ${SKIP_SYNC_TIME##*[!0-9]*} ]; then
		_e_error "SKIP_SYNC_TIME has no valid number or is not set, will use default (600)!"
		SKIP_SYNC_TIME="1800"
	fi

	if [ ${DINNER_USE_CCACHE} ] && [[ "${DINNER_USE_CCACHE}" =~ "^{0,1}$" ]]; then
		export USE_CCACHE=${DINNER_USE_CCACHE}
	fi

	if [ ${DINNER_CCACHE_DIR} ]; then
		export CCACHE_DIR=${DINNER_CCACHE_PATH}
	fi

	if [ ${DINNER_CCACHE_SIZE} ] && [ -z ${DINNER_CCACHE_SIZE##*[!0-9]*} ]; then
		_exec_command "${REPO_DIR}/prebuilts/misc/linux-x86/ccache/ccache -M ${DINNER_CCACHE_SIZE}" "_e_error \"There was an error while setting ccache size, take a look into the logs.\""
	fi

	if [ ${CLEANUP_OLDER_THAN} ] && [ -z "${CLEANUP_OLDER_THAN##*[!0-9]*}" ]; then
		_e_error "CLEANUP_OLDER_THAN has no valid number set, won't use it!"
		CLEANUP_OLDER_THAN=""
	fi

	if [ "${TARGET_DIR}" ]; then
		TARGET_DIR=$(echo "${TARGET_DIR}"|sed 's/\/$//g')
	fi
}

function _sync_repo () {
	_e_pending "repo sync..."
	if ! ${FORCE_SYNC} && ! ${SKIP_SYNC} && [ -f "${CURRENT_LASTSYNC_MEM}" ] && [ $(($(date +%s)-$(cat "${CURRENT_LASTSYNC_MEM}"))) -lt ${SKIP_SYNC_TIME} ]; then
		_e_pending_skipped "Skipping repo sync, it was alread synced in the last ${SKIP_SYNC_TIME} seconds."
	else
		if ${FORCE_SYNC} || ! ${SKIP_SYNC}; then
			_exec_command "${REPO_BIN} sync ${SYNC_PARAMS:-'-q -d -j100'}" "_e_pending_error \"Something went wrong  while doing repo sync\"" "_e_pending_success \"Successfully synced repo\""
			CURRENT_SYNC_REPO_EXIT_CODE=$?
			if [ "${CURRENT_SYNC_REPO_EXIT_CODE}" == 0 ]; then
				echo $(date +%s) > "${CURRENT_LASTSYNC_MEM}"
			fi
		else
			_e_pending_skipped "Skipping repo sync..."
			CURRENT_SYNC_REPO_EXIT_CODE=0
		fi
	fi
}

function _repo_pick () {
	if [ "${#CURRENT_REPOPICK[@]}" ]; then
		if [ -x ${REPO_DIR}/build/tools/repopick.py ]; then
			export ANDROID_BUILD_TOP=${REPO_DIR}
			for CHANGE in ${CURRENT_REPOPICK[@]}; do
				_exec_command "${REPO_DIR}/build/tools/repopick.py ${CHANGE}"
			done
		else
			_e_error "Could not find repopick.py, cannot make a repopick."
		fi
	fi
}

function _get_breakfast_variables () {
	_e_pending "Breakfast and getting its variables..."
	for VARIABLE in $(breakfast ${CURRENT_DEVICE} | sed -e 's/^=.*//' -e 's/[ ^I]*$//' -e '/^$/d' | grep -E '^[A-Z_]+=(.*)'); do
		eval "${VARIABLE}"
	done
	_e_pending_success "Breakfast finished"
}

function _brunch_device () {
	_e_pending "Brunch for config \"${CURRENT_CONFIG}\" (Device: ${CURRENT_DEVICE}) with version ${PLATFORM_VERSION}..."
	_exec_command "brunch ${CURRENT_DEVICE}"
	CURRENT_BRUNCH_DEVICE_EXIT_CODE=${?}
	CURRENT_OUTPUT_FILE=$(tail ${CURRENT_ERRLOG} | grep -i "Package complete:" | awk '{print $3}' | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" )
	CURRENT_BRUNCH_RUN_TIME=$(tail ${CURRENT_ERRLOG} | grep "real" | awk '{print $2}' | tr -d ' ')
	if [ "${CURRENT_BRUNCH_DEVICE_EXIT_CODE}" == 0 ]; then
		_e_pending_success "Brunch of config ${CURRENT_CONFIG} finished after ${CURRENT_BRUNCH_RUN_TIME}"
		_check_build
		if ${CURRENT_BUILD_STATUS}; then
			CURRENT_STATUS="finished successfully"
			_post_build_command
			_move_build
			_clean_old_builds
		else
			CURRENT_POST_BUILD_COMMAND_EXIT_CODE=0
			CURRENT_MOVE_BUILD_EXIT_CODE=0
			CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE=0
		fi
	else
		_e_pending_error "Brunch of config ${CURRENT_CONFIG} failed after ${CURRENT_BRUNCH_RUN_TIME}, see logfile for more information"
	fi
}

function _move_build () {
	if [ "${CURRENT_TARGET_DIR}" ]; then
		if [ -d "${CURRENT_TARGET_DIR}/" ]; then
			_e_notice "Moving files to target directory..."
			_exec_command "mv ${CURRENT_OUTPUT_FILE}* ${CURRENT_TARGET_DIR}/" "_e_warning \"Something went wrong while moving the build\""
			CURRENT_MOVE_BUILD_EXIT_CODE=$?
		else
			_e_error "${CURRENT_TARGET_DIR}/ is not a Directory. Will not move the File."
		fi
	else
		CURRENT_MOVE_BUILD_EXIT_CODE=0
	fi
}

function _pre_build_command () {
	if [ ${CURRENT_PRE_BUILD_COMMAND} ]; then
		_e_pending "pre build command..."
		_exec_command "${CURRENT_PRE_BUILD_COMMAND}" "_e_warning \"Something went wrong while running your pre build command\"" "_e_success \"Succesfully run pre build command\""
		CURRENT_PRE_BUILD_COMMAND_EXIT_CODE=$?
	else
		CURRENT_PRE_BUILD_COMMAND_EXIT_CODE=0
	fi
}

function _post_build_command () {
	if [ ${CURRENT_POST_BUILD_COMMAND} ]; then
		_e_pending "post build command..."
		_exec_command "${CURRENT_POST_BUILD_COMMAND}" "_e_warning \"Something went wrong while running your post build command\"" "_e_success \"Succesfully run post build command\""
		CURRENT_POST_BUILD_COMMAND_EXIT_CODE=$?
	else
		CURRENT_POST_BUILD_COMMAND_EXIT_CODE=0
	fi
}

function _clean_old_builds () {
	if [ "${CURRENT_CLEANUP_OLDER_THAN}" ]; then
		_e_pending "Running cleanup of old builds..."
		if [ "${CURRENT_TARGET_DIR}" ] && [ -d "${CURRENT_TARGET_DIR}/" ]; then
			_exec_command "CURRENT_CLEANED_FILES=\"$(find ${CURRENT_TARGET_DIR}/ -name "omni-${PLATFORM_VERSION}-*-${CURRENT_DEVICE}-HOMEMADE.zip*" -type f -mtime +${CURRENT_CLEANUP_OLDER_THAN} -delete)\""
		else
			_exec_command "CURRENT_CLEANED_FILES=\"$(find `dirname ${CURRENT_OUTPUT_FILE}` -name "omni-${PLATFORM_VERSION}-*-${CURRENT_DEVICE}-HOMEMADE.zip*" -type f -mtime +${CURRENT_CLEANUP_OLDER_THAN} -delete)\""
		fi
		CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE=$?
		if [ "${CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE}" != 0 ] && [ ! "${CURRENT_CLEANED_FILES}" ]; then
			_e_pending_success "Cleanup skipped, nothing to clean up for ${CURRENT_CONFIG}."
		elif [ "${CURRENT_CLEANED_FILES}" ]; then
			_e_pending_success "Cleanup finished, removed the following files: ${CURRENT_CLEANED_FILES}"
		elif [ "${CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE}" != 0 ]; then
			_e_pending_error "Something went wrong while cleaning builds for ${CURRENT_CONFIG}." "${CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE}"
		fi
	else
		CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE=0
	fi
}

function _send_mail () {
	if [ ${MAIL_BIN} ] && ([ "${CURRENT_MAIL}" ] || [ "${CURRENT_ADMIN_MAIL}" ]); then
		if ${CURRENT_BUILD_STATUS}; then
			_generate_user_message "Build for ${CURRENT_DEVICE} was successfully finished after ${CURRENT_BRUNCH_RUN_TIME}\n"
			_generate_admin_message "Used config \"${CURRENT_CONFIG}\"\n"
			if [ "${CURRENT_DOWNLOAD_LINK}" ]; then
				_generate_user_message "You can download your Build at ${CURRENT_DOWNLOAD_LINK}\n\n"
			fi

			if [ -f ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt ]; then
				_generate_user_message "$($(which cat) ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt)"
			fi

			if [ "${CURRENT_CLEANED_FILES}" ]; then
				_generate_admin_message "Removed the following files:"
				_generate_admin_message "${CURRENT_CLEANED_FILES}"
			fi
		else
			_generate_user_message "Build has failed after ${CURRENT_BRUNCH_RUN_TIME}.\n\n"
			if [ -f ${CURRENT_LOG} ]; then
				_generate_admin_message "Logfile attached"
				cat ${CURRENT_LOG} | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" > ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.log
				LOGFILE="-a \"${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}.log\""
			else
				_generate_admin_message "ERROR: Logfile not found"
			fi
			if [ -f ${CURRENT_ERRLOG} ]; then
				_generate_admin_message "Error Logfile attached"
				cat ${CURRENT_ERRLOG} | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" > ${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}_error.log
				ERRLOGFILE="-a \"${DINNER_TEMP_DIR}/dinner_${CURRENT_CONFIG}_error.log\""
			else
				_generate_admin_message "ERROR: Error Logfile not found"
			fi
		fi

		_generate_user_message "\e[21m"

		if [ "${CURRENT_MAIL}" ]; then
			_e_pending "Sending User E-Mail..."
		_exec_command "$(which cat) \"${DINNER_TEMP_DIR}/mail_user_message.txt\" | ${ANSI2HTML_BIN} | ${MAIL_BIN} -e \"set content_type=text/html\" -s \"[Dinner] Build for ${CURRENT_DEVICE} ${CURRENT_STATUS} (${CURRENT_BRUNCH_RUN_TIME})\" \"${CURRENT_MAIL}\"" "_e_pending_error \"Something went wrong while sending User E-Mail\"" "_e_pending_success \"Successfully send User E-Mail\""
			CURRENT_SEND_MAIL_EXIT_CODE=$?
		fi

		if [ "${CURRENT_ADMIN_MAIL}" ]; then
			_e_pending "Sending Admin E-Mail..."
			_exec_command "$(which cat) \"${DINNER_TEMP_DIR}/mail_user_message.txt\" \"${DINNER_TEMP_DIR}/mail_admin_message.txt\" | ${ANSI2HTML_BIN} | ${MAIL_BIN} -e \"set content_type=text/html\" -s \"[Dinner] Build for ${CURRENT_DEVICE} ${CURRENT_STATUS} (${CURRENT_BRUNCH_RUN_TIME})\" \"${CURRENT_ADMIN_MAIL}\" ${LOGFILE} ${ERRLOGFILE}" "_e_pending_error \"Something went wrong while sending Admin E-Mail\""  "_e_pending_success \"Successfully send Admin E-Mail\""
			CURRENT_SEND_MAIL_EXIT_CODE=$(($CURRENT_SEND_MAIL_EXIT_CODE + $?))
		fi
	else
		CURRENT_SEND_MAIL_EXIT_CODE=0
	fi
}

function _check_build () {
	if [ -f "${CURRENT_OUTPUT_FILE}" ]; then
		CURRENT_OUT_FILE_SECONDS_SINCE_CREATION=$(/bin/date -d "now - $( /usr/bin/stat -c "%Y" ${CURRENT_OUTPUT_FILE} ) seconds" +%s)
		if [ "${CURRENT_OUT_FILE_SECONDS_SINCE_CREATION}" -lt "120" ] ; then
			CURRENT_BUILD_STATUS=true
		else
			_e_error "Outputfile too old!"
		fi
	else
		_e_error "Outputfile does not exist!"
	fi
}

function _dinner_make {
	if [ ${CURRENT_DINNER_MAKE} ]; then
		CURRENT_BUILD_SKIPPED=true
		_e_pending "make ${CURRENT_DINNER_MAKE}..."
		_exec_command "make ${CURRENT_DINNER_MAKE}" '_e_pending_error "Failed"' '_e_pending_success "Done"'
		if ${CURRENT_CLEAN_ONLY}; then
			_check_current_config
			continue
		fi
	fi
}

function _check_current_config () {
	CURRENT_CONFIG_EXIT_CODE=$(( \
		${SYNC_REPO_EXIT_CODE} \
		+${CURRENT_BRUNCH_DEVICE_EXIT_CODE} \
		+${CURRENT_MOVE_BUILD_EXIT_CODE} \
		+${CURRENT_CLEAN_OLD_BUILDS_EXIT_CODE} \
		+${CURRENT_SEND_MAIL_EXIT_CODE} \
	))
	if ${CURRENT_BUILD_SKIPPED}; then
		SUCCESS_CONFIGS="${SUCCESS_CONFIGS}\"${CURRENT_CONFIG}\" "
	elif ${CURRENT_BUILD_STATUS} && [ "${CURRENT_CONFIG_EXIT_CODE}" -eq 0 ]; then
		SUCCESS_CONFIGS="${SUCCESS_CONFIGS}\"${CURRENT_CONFIG}\" "
		_set_lastbuild
	elif ${CURRENT_BUILD_STATUS} && [ "${CURRENT_CONFIG_EXIT_CODE}" -gt 0 ]; then
		WARNING_CONFIGS="${WARNING_CONFIGS}\"${CURRENT_CONFIG}\" "
	elif ! ${CURRENT_BUILD_STATUS} && [ "${CURRENT_CONFIG_EXIT_CODE}" -eq 0 ]; then
		_e_error "Buildcheck for config \"${CURRENT_CONFIG}\" has failed but overall exit code is fine" "${CURRENT_CONFIG_EXIT_CODE}"
		FAILED_CONFIGS="${FAILED_CONFIGS}\"${CURRENT_CONFIG}\" "
	elif ! ${CURRENT_BUILD_STATUS}; then
		FAILED_CONFIGS="${FAILED_CONFIGS}\"${CURRENT_CONFIG}\" "
	else
		_e_error "Could not determine status for config \"${CURRENT_CONFIG}\"" "${CURRENT_CONFIG_EXIT_CODE}"
	fi
	OVERALL_EXIT_CODE=$((${OVERALL_EXIT_CODE}+${CURRENT_CONFIG_EXIT_CODE}))
}

function _set_lastbuild () {
	echo $(date +%m/%d/%Y) > ${DINNER_TEMP_DIR}/lastbuild_${CURRENT_CONFIG}.txt
}

function _get_changelog () {
	_e_pending "Gathering Changes since last successfull build..."
	if [ -f "${DINNER_TEMP_DIR}/lastbuild_${CURRENT_CONFIG}.txt" ]; then
		LASTBUILD=$($(which cat) ${DINNER_TEMP_DIR}/lastbuild_${CURRENT_CONFIG}.txt)

		echo -e "\nChanges since last build ${LASTBUILD}"  > ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt
		echo -e "=====================================================\n"  >> ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt
		find ${REPO_DIR} -name .git | sed 's/\/.git//g' | sed 'N;$!P;$!D;$d' | while read line
		do
			cd $line
			log=$(git log --pretty="%an - %s" --since=${LASTBUILD} --date-order)
			project=$(git remote -v | head -n1 | awk '{print $2}' | sed 's/.*\///' | sed 's/\.git//')
			if [ ! -z "$log" ]; then
				origin=`grep "$project" ${REPO_DIR}/.repo/manifest.xml | awk {'print $4'} | cut -f2 -d '"'`

				if [ "$origin" = "bam" ]; then
						proj_credit=JELLYBAM
				elif [ "$origin" = "aosp" ]; then
						proj_credit=AOSP
				elif [ "$origin" = "cm" ]; then
						proj_credit=CyanogenMod
				else
						proj_credit="OmniROM"
				fi

				echo "$proj_credit Project name: $project" >> ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt

				echo "$log" | while read line
				do
					echo "  .$line" >> ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt
				done

				echo "" >> ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt
			fi
		done
		if ${CURRENT_CHANGELOG_ONLY}; then
			CURRENT_BUILD_SKIPPED=true
			[[ -f ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt ]] && _e_pending_success "Showing changelog:" && cat ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt || _e_pending_error "No Changelog found"
			_check_current_config
			continue
		fi
	else
		_e_pending_warn "Skipping gathering changes, no successfull build for config \"${CURRENT_CONFIG}\" found."
		if ${CURRENT_CHANGELOG_ONLY}; then
			CURRENT_BUILD_SKIPPED=true
			_e_pending "Searching last changelog..."
			sleep 3
			[[ -f ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt ]] && _e_pending_success "Showing last changelog:" && cat ${DINNER_TEMP_DIR}/changes_${CURRENT_CONFIG}.txt || _e_pending_error "No Changelog found"
			_check_current_config
			continue
		fi
	fi

}

function _cleanup () {
	local TEMPFILES="mail_admin_message.txt mail_user_message.txt dinner_update.log dinner_update.err dinner_${CURRENT_CONFIG}.log dinner_${CURRENT_CONFIG}_error.log"
	for TEMPFILE in ${TEMPFILES}; do
		if [ -e ${DINNER_TEMP_DIR}/${TEMPFILE} ]; then
			rm ${DINNER_TEMP_DIR}/${TEMPFILE}
		fi
	done
	eval "find ${DINNER_LOG_DIR} $(_print_configs '! -name *%s* ') ! -name .empty ! -name dinner_general* -type f -exec rm {} \;"
	eval "find ${REPO_DIR}/.repo/local_manifests/ -name dinner* $(_print_configs '! -name *%s* ') -type f -exec rm {} \;"
}

function _clear_logs () {
	[[ ${1} ]] && [[ ${1} =~ ^[0-9]+$ ]] && local OLDER_THAN="-mtime ${1}" || local OLDER_THAN=""
	[[ ${2} ]] && local CONFIG="${2}" || local CONFIG=""
	_e_pending "Cleaning logfiles for ${CONFIG}..."
	_exec_command "find ${DINNER_LOG_DIR} -name \"*${CONFIG}*.log\" -type f ${OLDER_THAN} -exec rm {} \;" "_e_pending_error \"Something went wrong will cleaning logs for ${CONFIG}\"" "_e_pending_success \"Successfull cleaned logs for ${CONFIG}\""
}

function _list_configs {
	printf "${bldwht}%s${txtdef}\n" "Available Configs:"
	while IFS= read -d $'\n' -r config ; do
		printf "\t\t%s\n" "$config"
	done < <(_print_configs)
	exit $EX_SUCCESS
}

function _print_configs {
	[[ ${1} ]] && local ARGS="${1}" || local ARGS="%b\n"
	while IFS= read -d $'\0' -r configpath ; do
		local config=$(basename "${configpath}")
		printf "${ARGS}" "$config"
	done < <(find "${CONFIG_DIR}" -mindepth 1 -maxdepth 1 -type f ! -name *example.dist -print0 | sort -z)
	return $EX_SUCCESS
}

function _run_config () {
	case ${1} in
		"changelog")
			CURRENT_CHANGELOG_ONLY=true
			CURRENT_CONFIG=${2}
			;;
		"make")
			CURRENT_CLEAN_ONLY=true
			CURRENT_DINNER_MAKE=${2}
			CURRENT_CONFIG=${3}
			;;
		"cook")
			CURRENT_CONFIG=${2}
			;;
		*)
			_e_fatal "Unknown command '$1'" $EX_USAGE
			;;
	esac

	_check_prerequisites

	_dinner_make

	_generate_local_manifest

	_sync_repo

	_repo_pick

	_get_changelog

	_get_breakfast_variables

	_pre_build_command

	_brunch_device

	_check_current_config

	_send_mail

	_cleanup
}
